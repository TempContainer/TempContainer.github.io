<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-25">

<title>Fluid Simulation I: Simulating Smoke Using the Eulerian Method – Zhenyi's Homepage</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../RI.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-7e66fd11ac23497b1f44352b3060d6fd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Zhenyi’s Homepage</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../index.html" aria-current="page"> <i class="bi bi-house-door" role="img">
</i> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> <i class="bi bi-vector-pen" role="img">
</i> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../blogs/smoke_sim.html">Fluid Simulation I: Simulating Smoke Using the Eulerian Method</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../blogs/smoke_sim.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Fluid Simulation I: Simulating Smoke Using the Eulerian Method</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#depiction-of-the-fluid" id="toc-depiction-of-the-fluid" class="nav-link active" data-scroll-target="#depiction-of-the-fluid"><span class="header-section-number">1</span> Depiction of the Fluid</a>
  <ul class="collapse">
  <li><a href="#conservation-of-mass" id="toc-conservation-of-mass" class="nav-link" data-scroll-target="#conservation-of-mass"><span class="header-section-number">1.1</span> Conservation of Mass</a></li>
  <li><a href="#conservation-of-momentum" id="toc-conservation-of-momentum" class="nav-link" data-scroll-target="#conservation-of-momentum"><span class="header-section-number">1.2</span> Conservation of Momentum</a></li>
  <li><a href="#incompressible-navier-stokes-equations" id="toc-incompressible-navier-stokes-equations" class="nav-link" data-scroll-target="#incompressible-navier-stokes-equations"><span class="header-section-number">1.3</span> Incompressible Navier-Stokes Equations</a></li>
  </ul></li>
  <li><a href="#numerical-simulation" id="toc-numerical-simulation" class="nav-link" data-scroll-target="#numerical-simulation"><span class="header-section-number">2</span> Numerical Simulation</a>
  <ul class="collapse">
  <li><a href="#discretization-of-time-the-splitting-method" id="toc-discretization-of-time-the-splitting-method" class="nav-link" data-scroll-target="#discretization-of-time-the-splitting-method"><span class="header-section-number">2.1</span> Discretization of Time: The Splitting Method</a></li>
  <li><a href="#discretization-of-space-the-mac-grid" id="toc-discretization-of-space-the-mac-grid" class="nav-link" data-scroll-target="#discretization-of-space-the-mac-grid"><span class="header-section-number">2.2</span> Discretization of Space: The MAC Grid</a></li>
  <li><a href="#advection" id="toc-advection" class="nav-link" data-scroll-target="#advection"><span class="header-section-number">2.3</span> Advection</a></li>
  <li><a href="#body-force" id="toc-body-force" class="nav-link" data-scroll-target="#body-force"><span class="header-section-number">2.4</span> Body Force</a></li>
  <li><a href="#cfl-condition" id="toc-cfl-condition" class="nav-link" data-scroll-target="#cfl-condition"><span class="header-section-number">2.5</span> CFL Condition</a></li>
  <li><a href="#enforcing-incompressibility" id="toc-enforcing-incompressibility" class="nav-link" data-scroll-target="#enforcing-incompressibility"><span class="header-section-number">2.6</span> Enforcing Incompressibility</a></li>
  </ul></li>
  <li><a href="#code-sample-2d-smoke-simulation" id="toc-code-sample-2d-smoke-simulation" class="nav-link" data-scroll-target="#code-sample-2d-smoke-simulation"><span class="header-section-number">3</span> Code Sample: 2D Smoke Simulation</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">4</span> References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Fluid Simulation I: Simulating Smoke Using the Eulerian Method</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i></button></div></div>
  <div class="quarto-categories">
    <div class="quarto-category">physics-simulation</div>
    <div class="quarto-category">fluid</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">2025-08-25</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">2025-08-25</p>
    </div>
  </div>
    
  </div>
  


</header>


<p>In this series, we will explore the fundamentals of fluid simulation, focusing on substances like smoke and water. In this first post, we introduce the mathematical framework for describing fluid behavior and develop a classic technique—the Eulerian Method—for simulating fluids. We use smoke as a particular example to illustrate the details of this approach.</p>
<section id="depiction-of-the-fluid" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="depiction-of-the-fluid"><span class="header-section-number">1</span> Depiction of the Fluid</h2>
<p>We describe fluid as a field, where every position <span class="math inline">\(\mathbf{x}\)</span> is associated with physical quantities, such as velocity <span class="math inline">\(\mathbf{u}(\mathbf{x})\)</span> and density <span class="math inline">\(\rho(\mathbf{x})\)</span>. By referring to “every position”, we implicitly invoke the assumption of continuity: at the macroscopic scale, the medium is fine enough that every point is well-defined; yet at the microscopic scale, it is large enough to average out the complexities of quantum effects and the detailed motions of molecules. Thus, the properties of the bulk material can be described by continuous functions, and their evolution can be studied using calculus.</p>
<section id="conservation-of-mass" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="conservation-of-mass"><span class="header-section-number">1.1</span> Conservation of Mass</h3>
<p>Consider any fixed region of space <span class="math inline">\(\Omega\)</span> in the fluid. The mass of the fluid in <span class="math inline">\(\Omega\)</span> is <span class="math display">\[M = \iiint_{\Omega} \rho \, \mathrm{d}V.\]</span> Based on conservation of mass, the rate of change of <span class="math inline">\(M\)</span>, as fluid flows in or out of <span class="math inline">\(\Omega\)</span>, is given by the integral around the boundary of the speed at which mass enters or exits, since mass cannot be created or destroyed inside <span class="math inline">\(\Omega\)</span>: <span class="math display">\[\frac{ \partial M }{ \partial t } = - \iint_{\partial \Omega} \rho \mathbf{u} \cdot \mathbf{n} \, \mathrm{d}S.\]</span> Here <span class="math inline">\(\mathbf{n}\)</span> is the outward-pointing normal. Expanding <span class="math inline">\(M\)</span> and applying the divergence theorem, we obtain <span class="math display">\[\iiint_{\Omega} \frac{ \partial \rho }{ \partial t } \, \mathrm{d}V = - \iiint_{\Omega} \nabla \cdot (\rho \mathbf{u}) \, \mathrm{d}V.\]</span> Since this is true for any region <span class="math inline">\(\Omega\)</span>, the integrands must match: <span class="math display">\[\frac{ \partial \rho }{ \partial t } + \nabla \cdot (\rho \mathbf{u}) = 0.\]</span> This is called the <strong>continuity equation</strong>.</p>
</section>
<section id="conservation-of-momentum" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="conservation-of-momentum"><span class="header-section-number">1.2</span> Conservation of Momentum</h3>
<p>To analyze the behavior of the fluid, we consider an arbitrary blob of fluid <span class="math inline">\(\Omega(t)\)</span> as our subject. The momentum of the blob can change in two ways: through body forces applied to every point in the region, such as gravity, and through stresses that neighboring blobs or other continuous material exert on the boundary. A common stress in fluid mechanics is pressure, which arises from the collective force of innumerable particle collisions at the microscopic level. <span class="math display">\[
\iiint_{\Omega(t)} \rho \frac{ \mathrm{D} \mathbf{u} }{ \mathrm{D} t } \, \mathrm{d}V = \iiint_{\Omega(t)} \rho \mathbf{f} \, \mathrm{d}V + \iint_{\partial \Omega(t)} \boldsymbol{\sigma} \cdot \mathrm{d}S
\]</span> You may notice the notation <span class="math inline">\(\frac{ \mathrm{D} \mathbf{u} }{ \mathrm{D} t }\)</span>—the material derivative. Why do we use this notation?</p>
<p>There are two approaches to tracking the motion of a continuum: the Lagrangian viewpoint and the Eulerian viewpoint. In the Lagrangian viewpoint, each point in the fluid is labeled as a separate particle, with a position <span class="math inline">\(\mathbf{x}\)</span> and a velocity <span class="math inline">\(\mathbf{u}\)</span>. In the Eulerian viewpoint, we instead look at fixed points in space and observe how measurements of fluid quantities, such as density, velocity, temperature, etc., at those points change over time. To illustrate, imagine a weather report: in the Lagrangian viewpoint, you’re in a balloon floating along with the wind, measuring the pressure, temperature, and humidity of the air around you; in the Eulerian viewpoint, you’re on the ground, measuring the properties of the air as it flows past.</p>
<p>Let’s look at how these two viewpoints relate mathematically. Start with a Lagrangian description: there are particles with positions <span class="math inline">\(\mathbf{x}\)</span> and velocities <span class="math inline">\(\mathbf{u}\)</span>. Consider a generic quantity <span class="math inline">\(q\)</span>; each particle has a value for <span class="math inline">\(q\)</span>. The function <span class="math inline">\(q(t, \mathbf{x})\)</span> tells us the value of <span class="math inline">\(q\)</span> at time <span class="math inline">\(t\)</span> for the particle at position <span class="math inline">\(\mathbf{x}\)</span>—an Eulerian variable, since it’s a function of space, not of particles. How fast is <span class="math inline">\(q\)</span> changing for the particle whose position is <span class="math inline">\(\mathbf{x}(t)\)</span> as a function of time? By the chain rule: <span class="math display">\[
\begin{align}
\frac{\mathrm{d}}{\mathrm{d}t} q(t,\mathbf{x}(t)) &amp; = \frac{ \partial q }{ \partial t } + \nabla q \cdot \frac{\mathrm{d} \mathbf{x}}{\mathrm{d}t}  \\
&amp;= \frac{ \partial q }{ \partial t } + \nabla q \cdot \mathbf{u} := \frac{ \mathrm{D} q }{ \mathrm{D} t }.
\end{align}
\]</span> This is called the <strong>material derivative</strong>. So now we can answer the question above: we describe the fluid’s quantities in the Eulerian viewpoint, but when deriving the conservation of momentum, we need to treat the blob as a particle, i.e., in the Lagrangian viewpoint.</p>
<p>Continuing, using the divergence theorem, we obtain <span class="math display">\[
\iiint_{\Omega(t)} \rho \frac{ \mathrm{D} \mathbf{u} }{ \mathrm{D} t } \, \mathrm{d}V = \iiint_{\Omega(t)} \rho \mathbf{f} \, \mathrm{d}V + \iiint_{\Omega(t)} \nabla \cdot \boldsymbol{\sigma} \, \mathrm{d}V
\]</span> Since this is true for any region <span class="math inline">\(\Omega(t)\)</span>, the integrands must match: <span class="math display">\[
\frac{ \mathrm{D} \mathbf{u} }{ \mathrm{D} t } = \frac{ \partial \mathbf{u} }{ \partial t } + (\mathbf{u} \cdot \nabla)\mathbf{u} = \mathbf{f} + \frac{1}{\rho} \nabla \cdot \boldsymbol{\sigma}.
\]</span> This is called the <strong>Cauchy momentum equation</strong>&nbsp;(convective form).</p>
</section>
<section id="incompressible-navier-stokes-equations" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="incompressible-navier-stokes-equations"><span class="header-section-number">1.3</span> Incompressible Navier-Stokes Equations</h3>
<p>We have obtained the general form for fluid motion. Now let’s make some approximations to arrive at the famous <strong>incompressible Navier-Stokes equations</strong>, which are widely used in computer graphics to simulate fluids. First, we take gravity as the body force and choose the stress to be <span class="math inline">\(\boldsymbol{\sigma} = -p\mathbf{I} + \mu(\nabla \mathbf{u} + (\nabla \mathbf{u})^\top)\)</span>. Thus, <span class="math display">\[
\nabla \cdot \boldsymbol{\sigma} = -\nabla p + \nu \nabla \cdot \nabla \mathbf{u},
\]</span> where <span class="math inline">\(\nu\)</span> is the kinematic viscosity, measuring how viscous the fluid is. Moreover, we require the fluid to be incompressible: for any fluid blob, its density must remain the same, i.e., <span class="math inline">\(\mathrm{D}\rho/\mathrm{D}t = 0\)</span>. We have <span class="math display">\[
\begin{align}
\frac{ \partial \rho }{ \partial t } + \nabla \cdot (\rho \mathbf{u}) &amp;= \frac{ \partial \rho }{ \partial t } + \mathbf{u} \cdot \nabla \rho + \rho \nabla \cdot \mathbf{u} \\
&amp;= \rho \nabla \cdot \mathbf{u} = 0 \\
&amp;\implies \nabla \cdot \mathbf{u} = 0.
\end{align}
\]</span> Putting these together, we have <span class="math display">\[
\begin{align}
\frac {\mathrm{D}\mathbf {u} }{\mathrm{D}t}={\frac {\partial \mathbf {u} }{\partial t}}+(\mathbf {u} \cdot \nabla )\mathbf {u} &amp;=\nu \,\nabla \cdot \nabla\mathbf {u} -{\frac {1}{\rho }}\nabla p+ \mathbf {g} \\
\nabla \cdot \mathbf{u} &amp;= 0.
\end{align}
\]</span> The first equation is the <strong>momentum equation</strong>, derived from conservation of momentum; it tells us how the fluid accelerates due to the forces acting on it. The second equation is the <strong>incompressibility condition</strong>.</p>
<p>Let’s discuss the viscosity term, <span class="math inline">\(\nu \nabla \cdot \nabla \mathbf{u}\)</span>. It is often written as the Laplacian: <span class="math inline">\(\nu\Delta \mathbf{u}\)</span>. The Laplacian operator “smooths” the field, making each quantity close to its neighbors’ mean value. Thus, the viscosity term means the fluid tends to minimize differences in velocity between nearby regions, manifesting as resistance to deformation.</p>
<p>However, in most cases relevant to animation, viscosity plays a minor role and is often neglected. In fact, most numerical methods for simulating fluids introduce errors that can be physically interpreted as viscosity—so even if we drop viscosity in the equations, we still obtain results that look physically plausible. The Navier-Stokes equations without viscosity are called the <strong>Euler equations</strong>, and an ideal fluid with no viscosity is called <strong>inviscid</strong>. Explicitly, <span class="math display">\[
\begin{align}
{\frac {\partial \mathbf {u} }{\partial t}}+(\mathbf {u} \cdot \nabla )\mathbf {u} &amp;=-{\frac {1}{\rho }}\nabla p+ \mathbf {g} \\
\nabla \cdot \mathbf{u} &amp;= 0.
\end{align}
\]</span> It is these equations that we’ll mostly be using.</p>
</section>
</section>
<section id="numerical-simulation" class="level2 page-columns page-full" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="numerical-simulation"><span class="header-section-number">2</span> Numerical Simulation</h2>
<section id="discretization-of-time-the-splitting-method" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="discretization-of-time-the-splitting-method"><span class="header-section-number">2.1</span> Discretization of Time: The Splitting Method</h3>
<p>Once we have the equations, we can simulate the fluid by numerically integrating them over time. However, directly solving the equations is difficult because they are nonlinear and coupled. A common approach is to use a <strong>splitting method</strong>, which breaks down the complex problem into simpler subproblems that can be solved sequentially.</p>
<p>To elaborate, let’s take a simple PDE as an example: <span class="math display">\[\frac{ \partial q }{ \partial t } = f(t) + g(t),\]</span> In each timestep, we will split it into two simpler equations and solve these two equations one after another to approximate the solution of the original equation: <span class="math display">\[\begin{aligned} \tilde{q} &amp;= q^n + f(q^n) \Delta t,  \\ q^{n+1} &amp;= \tilde{q} + g(\tilde{q}) \Delta t. \end{aligned}\]</span> After the first step, we get an intermediate quantity <span class="math inline">\(\tilde{q}\)</span> that includes the contribution of the first term but not the second, and then the second step goes from the intermediate value to the end by adding in the missing term’s contribution. A Taylor series analysis shows that this is still a first-order-accurate algorithm: <span class="math display">\[
\begin{aligned}
q^{n+1} &amp;= (q^n + f(q^n)\Delta t) + \Delta g(q^n + f(q^n)\Delta t) \\
&amp;= q^n + \Delta t f(q^n) + \Delta t(g(q^n) + O(\Delta t)) \\
&amp;= q^n + \Delta t (f(q^n) + g(q^n)) + O(\Delta t^2) \\
&amp;= q^n + \frac{\mathrm{d} q}{\mathrm{d}t} \Delta t + O(\Delta t^2).
\end{aligned}
\]</span></p>
<p>Therefore, we break down the N-S equations into three simpler parts, each corresponding to a physical phenomenon: advection, body forces, and pressure projection: <span class="math display">\[
\begin{aligned}
\frac{\mathrm{D}q}{\mathrm{D}t} &amp;= 0 \iff \frac{ \partial q }{ \partial t } = -(\nabla \cdot \mathbf{u}) q, \\
\frac{ \partial \mathbf{u} }{ \partial t } &amp;= \mathbf{g}, \\
\frac{ \partial \mathbf{u} }{ \partial t } &amp;= -\frac{1}{\rho} \nabla p \\
\text{s.t. } \nabla \cdot \mathbf{u} &amp;= 0.
\end{aligned}
\]</span> We used the generic quantity <span class="math inline">\(q\)</span> in the advection equation because we may not just advect velocity. In each timestep, we solve these three parts sequentially to update the velocity field.</p>
<p>The important guarantee is that advection should only be done in a divergence-free velocity field. When we move fluid around and want it to conserve volume, the velocity field we are moving it in must be divergence-free. So we want to make sure we only advect after enforcing the compressibility.</p>
</section>
<section id="discretization-of-space-the-mac-grid" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="discretization-of-space-the-mac-grid"><span class="header-section-number">2.2</span> Discretization of Space: The MAC Grid</h3>
<p>To represent the fluid fields in a computer, we discretize space into a grid. Each cell in the grid holds values for the fluid properties at that location. One common way to arrange these values is collocated grid, where all quantities (such as velocity components and scalar fields like pressure or density) are stored at the center of each grid cell. This layout is simple and intuitive, but it can suffer from numerical instabilities. For example, it may not resolve certain high-frequency oscillations (such as <span class="math inline">\((-1)^{i+j+k}\)</span> patterns), leading to spurious pressure and velocity artifacts.</p>
<p>Therefore, we use a staggered, marker-and-cell grid (MAC grid), where different quantities are stored at different positions within each cell. Typically, scalar quantities (like pressure or density) are stored at the cell centers, while the components of the velocity vector are stored at the centers of the cell faces perpendicular to their respective directions (e.g., <span class="math inline">\(u\)</span> at the center of the left/right faces, <span class="math inline">\(v\)</span> at the center of the top/bottom faces, <span class="math inline">\(w\)</span> at the center of the front/back faces in 3D). This spatial staggering helps to suppress numerical artifacts. A simple 2D illustration (for a cell at <span class="math inline">\((i, j)\)</span>):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/mac_grid.png" class="img-fluid figure-img" width="500"></p>
<figcaption>2D MAC grid at <span class="math inline">\((i, j)\)</span></figcaption>
</figure>
</div>
<p>When we want to compute the value of a quantity at a position where it is not stored, we can use interpolation. For example, to get the <span class="math inline">\(u\)</span> value at the cell center <span class="math inline">\((i, j)\)</span>, we can average the <span class="math inline">\(u\)</span> values at the left and right faces: <span class="math display">\[
u_{i,j} = \frac{u_{i-\frac{1}{2},j} + u_{i+\frac{1}{2},j}}{2}.
\]</span> To obtain a more accurate and less diffusive result, cubic interpolation is preferred. If the cubic polynomial passes through four points <span class="math inline">\(f_{-1}, f_0, f_1, f_2\)</span> at <span class="math inline">\(x = -1, 0, 1, 2\)</span>, then the value at any <span class="math inline">\(x \in [0, 1]\)</span> can be computed as <span class="math display">\[
f(x) = \left(-\tfrac{1}{2}x + x^2 - \tfrac{1}{2}x^3\right) f_{-1}
  + \left(1 - \tfrac{5}{2}x^2 + \tfrac{3}{2}x^3\right) f_0
  + \left(\tfrac{1}{2}x + 2x^2 - \tfrac{3}{2}x^3\right) f_1
  + \left(-\tfrac{1}{2}x^2 + \tfrac{1}{2}x^3\right) f_2.
\]</span></p>
</section>
<section id="advection" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="advection"><span class="header-section-number">2.3</span> Advection</h3>
<p>To solve advection, we can use finite difference schemes to approximate the spatial derivatives. However, these methods can introduce numerical instability, as forward Euler time integration is not stable. We will instead use a simple and more phisically-intuitive method. In Lagrangian viewpoint, each fluid particle moves with the flow. Thus, we can trace the path of a fluid particle backward in time to find where it came from, and then interpolate the quantity at that position to update the current position. This is called the <strong>semi-Lagrangian method</strong>.</p>
<p>To be more specific, consider a grid cell centered at <span class="math inline">\(\mathbf{x}_c\)</span>. We want to update the quantity <span class="math inline">\(q\)</span> at <span class="math inline">\(\mathbf{x}_c\)</span>. We trace the path of a imaginary fluid particle currently at <span class="math inline">\(\mathbf{x}_c\)</span> backward in time for one timestep <span class="math inline">\(\Delta t\)</span> using the velocity field <span class="math inline">\(\mathbf{u}\)</span>: <span class="math display">\[\mathbf{x}_p = \mathbf{x}_c - \mathbf{u}(\mathbf{x}_c) \Delta t.\]</span> Then we interpolate the value of <span class="math inline">\(q\)</span> at <span class="math inline">\(\mathbf{x}_p\)</span> using the values at nearby grid points. This gives us the updated value of <span class="math inline">\(q\)</span> at <span class="math inline">\(\mathbf{x}_c\)</span>: <span class="math display">\[q(\mathbf{x}_c) \leftarrow q(\mathbf{x}_p).\]</span></p>
<p>A more sophisticated technique such as a thrid-order Runge-Kutta (RK3) method can be used to trace the path more accurately, especially when the velocity field varies significantly within a timestep: <span class="math display">\[
\begin{aligned}
\mathbf{k}_1 &amp;= -\mathbf{u}(\mathbf{x}_c), \\
\mathbf{k}_2 &amp;= -\mathbf{u}(\mathbf{x}_c + \frac{1}{2} \Delta t \mathbf{k}_1), \\
\mathbf{k}_3 &amp;= -\mathbf{u}(\mathbf{x}_c + \frac{3}{4} \Delta t \mathbf{k}_2), \\
\mathbf{x}_p &amp;= \mathbf{x}_c + \frac{\Delta t}{9} (2\mathbf{k}_1 + 3\mathbf{k}_2 + 4\mathbf{k}_3).
\end{aligned}
\]</span></p>
</section>
<section id="body-force" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="body-force"><span class="header-section-number">2.4</span> Body Force</h3>
<p>For body force, we simply add the effect of gravity to the velocity field.</p>
</section>
<section id="cfl-condition" class="level3 page-columns page-full" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="cfl-condition"><span class="header-section-number">2.5</span> CFL Condition</h3>
<p>There is some confusion in the literature about exactly what this condition is. To keep as simple as possible, I will skip the details and just focus on what we need to implement. A more detailed explanation can be found in <span class="citation" data-cites="bridson2015fluid">Bridson (<a href="#ref-bridson2015fluid" role="doc-biblioref">2015</a>)</span>.</p>
<div class="no-row-height column-margin column-container"></div><p>The timestep <span class="math inline">\(\Delta t\)</span> must satisfy the CFL condition to ensure numerical stability. The CFL condition states that the fluid should not move more than <span class="math inline">\(C\)</span> grid cells in a single timestep. Mathematically, this can be expressed as <span class="math display">\[
\Delta t \leq \frac{C\Delta x}{|u|},
\]</span> where <span class="math inline">\(\Delta x\)</span> are the grid cell size, and <span class="math inline">\(u\)</span> are the velocity. <span class="math inline">\(C\)</span> is a small constant integer typically set to <span class="math inline">\(5\)</span>.</p>
</section>
<section id="enforcing-incompressibility" class="level3" data-number="2.6">
<h3 data-number="2.6" class="anchored" data-anchor-id="enforcing-incompressibility"><span class="header-section-number">2.6</span> Enforcing Incompressibility</h3>
<p>To enforce incompressibility, We begin with the velocity update formula <span class="math display">\[
u^{n+1} = u^{n} - \Delta t \frac{\nabla p}{\rho}.
\]</span> For incompressible flow, we have the continuity constraint: <span class="math display">\[
\nabla \cdot u^{n+1} = 0.
\]</span> Substituting the velocity update into the continuity equation: <span class="math display">\[
\nabla \cdot \left(u^{n} - \Delta t \frac{\nabla p}{\rho}\right) = 0.
\]</span> This gives us the pressure Poisson equation: <span class="math display">\[
\nabla \cdot \left(\frac{\nabla p}{\rho}\right) = \frac{1}{\Delta t} \nabla \cdot u^{n}.
\]</span> For constant density <span class="math inline">\(\rho\)</span>, this simplifies to: <span class="math display">\[
\Delta p = \frac{\rho}{\Delta t} \nabla \cdot u^{n}.
\]</span> We can explain this process in a more mathematically rigorous way: the incompressibility condition, <span class="math inline">\(\nabla \cdot \mathbf{u} = 0\)</span>, serves as a constraint in the fluid system. When we enforce this constraint during simulation, the pressure field <span class="math inline">\(p\)</span> naturally emerges as a Lagrange multiplier.</p>
<p>In the context of constrained optimization, a Lagrange multiplier is introduced to enforce a constraint while minimizing (or extremizing) some quantity—in this case, the kinetic energy of the fluid. For incompressible flow, we seek a velocity field that is as close as possible to the unconstrained (intermediate) velocity, but which also satisfies the divergence-free condition. The pressure term in the Navier-Stokes equations acts as the Lagrange multiplier that enforces this constraint at every point in the domain.</p>
<p>Mathematically, this means that the pressure is not an independent physical variable, but rather a quantity that arises to ensure the velocity field remains divergence-free. When we solve the pressure Poisson equation during the projection step, we are effectively finding the Lagrange multiplier that enforces incompressibility.</p>
<p>Combining the discrete operators, we get the discrete pressure Poisson equation: <span class="math display">\[
\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{(\Delta x)^2} + \frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{(\Delta y)^2} = \frac{\rho}{\Delta t} \left( \frac{u^n_{i+\frac{1}{2},j} - u^n_{i-\frac{1}{2},j}}{\Delta x} + \frac{v^n_{i,j+\frac{1}{2}} - v^n_{i,j-\frac{1}{2}}}{\Delta y} \right).
\]</span> Let <span class="math inline">\(N_x\)</span> and <span class="math inline">\(N_y\)</span> be the number of cells in x and y directions. We have <span class="math inline">\(N_x \times N_y\)</span> unknown pressures. The discrete equation can be written as: <span class="math display">\[
A\mathbf{p} = \mathbf{b}.
\]</span> where <span class="math inline">\(\mathbf{p}\)</span> is the pressure vector of size <span class="math inline">\(N_x N_y \times 1\)</span>; <span class="math inline">\(A\)</span> is the coefficient matrix of size <span class="math inline">\(N_x N_y \times N_x N_y\)</span>; <span class="math inline">\(\mathbf{b}\)</span> is the right-hand side vector of size <span class="math inline">\(N_x N_y \times 1\)</span>.</p>
<p>This sparse linear system can be solved using iterative methods such as the Conjugate Gradient (CG) method or Multigrid methods. A preconditioner, such as the MIC(0) (Modified Incomplete Cholesky with zero-fill), can be used to accelerate convergence. After obtaining the pressure field, we can update the velocity field to ensure it is divergence-free.</p>
</section>
</section>
<section id="code-sample-2d-smoke-simulation" class="level2 page-columns page-full" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="code-sample-2d-smoke-simulation"><span class="header-section-number">3</span> Code Sample: 2D Smoke Simulation</h2>
<p>The code sample demonstrates a simple 2D smoke simulation implemented in Python using the warp library. You could find it on <a href="https://github.com/TempContainer/simple-fluid">GitHub</a>. The simulation solves the incompressible Euler equations on a MAC grid, using semi-Lagrangian advection, pressure projection, and buoyancy forces as body force to model the motion of smoke. The results are visualized in real time using Matplotlib.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><video src="../assets/smoke2d.mp4" class="img-fluid" controls=""><a href="../assets/smoke2d.mp4">Video</a></video></p>
<figcaption>2D smoke simulation</figcaption>
</figure>
</div>
<div class="page-columns page-full"><p>A major advantage of using cubic interpolation is evident when comparing my implementation to warp’s official fluid simulation demo, which use linear interpolation.  The cubic approach produces noticeably finer and more detailed turbulence patterns in the simulated smoke.</p><div class="no-row-height column-margin column-container"><span class="margin-aside">Also they do not use MAC grid, RK3 integration scheme, and a conjugate gradient solver to solve the Poisson equation.</span></div></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/warp_fluid.png" class="img-fluid figure-img"></p>
<figcaption>warp’s official fluid simulation. Poor turbulence detail is showed as the absence of high-order interpolation.</figcaption>
</figure>
</div>
</section>
<section id="references" class="level2 page-columns page-full" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="references"><span class="header-section-number">4</span> References</h2>
<p>Most of the content in this post is adapted from <span class="citation" data-cites="bridson2015fluid">Bridson (<a href="#ref-bridson2015fluid" role="doc-biblioref">2015</a>)</span>, which is an excellent book on fluid simulation for beginners. Also, <span class="citation" data-cites="kim2017fluid">Kim (<a href="#ref-kim2017fluid" role="doc-biblioref">2017</a>)</span> is a great resource with code samples for fluid simulation.</p>


<!-- -->

<div class="no-row-height column-margin column-container"><div id="ref-bridson2015fluid" class="csl-entry" role="listitem">
Bridson, Robert. 2015. <em>Fluid Simulation for Computer Graphics</em>. USA: A. K. Peters, Ltd.
</div><div id="ref-kim2017fluid" class="csl-entry" role="listitem">
Kim, Doyub. 2017. <em>Fluid Engine Development</em>. New York: A K Peters/CRC Press.
</div></div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/TempContainer\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Fluid Simulation I: Simulating Smoke Using the Eulerian Method"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> "8/25/2025"</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> "8/25/2025"</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="an">image:</span><span class="co"> ../assets/smoke_teaser.png</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">  - physics-simulation</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">  - fluid</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>In this series, we will explore the fundamentals of fluid simulation, focusing on substances like smoke and water. In this first post, we introduce the mathematical framework for describing fluid behavior and develop a classic technique—the Eulerian Method—for simulating fluids. We use smoke as a particular example to illustrate the details of this approach.</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="fu">## Depiction of the Fluid</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>We describe fluid as a field, where every position $\mathbf{x}$ is associated with physical quantities, such as velocity $\mathbf{u}(\mathbf{x})$ and density $\rho(\mathbf{x})$. By referring to "every position", we implicitly invoke the assumption of continuity: at the macroscopic scale, the medium is fine enough that every point is well-defined; yet at the microscopic scale, it is large enough to average out the complexities of quantum effects and the detailed motions of molecules. Thus, the properties of the bulk material can be described by continuous functions, and their evolution can be studied using calculus.</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="fu">### Conservation of Mass</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>Consider any fixed region of space $\Omega$ in the fluid. The mass of the fluid in $\Omega$ is $$M = \iiint_{\Omega} \rho \, \mathrm{d}V.$$ Based on conservation of mass, the rate of change of $M$, as fluid flows in or out of $\Omega$, is given by the integral around the boundary of the speed at which mass enters or exits, since mass cannot be created or destroyed inside $\Omega$: $$\frac{ \partial M }{ \partial t } = - \iint_{\partial \Omega} \rho \mathbf{u} \cdot \mathbf{n} \, \mathrm{d}S.$$ Here $\mathbf{n}$ is the outward-pointing normal. Expanding $M$ and applying the divergence theorem, we obtain $$\iiint_{\Omega} \frac{ \partial \rho }{ \partial t } \, \mathrm{d}V = - \iiint_{\Omega} \nabla \cdot (\rho \mathbf{u}) \, \mathrm{d}V.$$ Since this is true for any region $\Omega$, the integrands must match: $$\frac{ \partial \rho }{ \partial t } + \nabla \cdot (\rho \mathbf{u}) = 0.$$ This is called the **continuity equation**. </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="fu">### Conservation of Momentum</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>To analyze the behavior of the fluid, we consider an arbitrary blob of fluid $\Omega(t)$ as our subject. The momentum of the blob can change in two ways: through body forces applied to every point in the region, such as gravity, and through stresses that neighboring blobs or other continuous material exert on the boundary. A common stress in fluid mechanics is pressure, which arises from the collective force of innumerable particle collisions at the microscopic level. </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>\iiint_{\Omega(t)} \rho \frac{ \mathrm{D} \mathbf{u} }{ \mathrm{D} t } \, \mathrm{d}V = \iiint_{\Omega(t)} \rho \mathbf{f} \, \mathrm{d}V + \iint_{\partial \Omega(t)} \boldsymbol{\sigma} \cdot \mathrm{d}S</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>You may notice the notation $\frac{ \mathrm{D} \mathbf{u} }{ \mathrm{D} t }$—the material derivative. Why do we use this notation? </span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>There are two approaches to tracking the motion of a continuum: the Lagrangian viewpoint and the Eulerian viewpoint. In the Lagrangian viewpoint, each point in the fluid is labeled as a separate particle, with a position $\mathbf{x}$ and a velocity $\mathbf{u}$. In the Eulerian viewpoint, we instead look at fixed points in space and observe how measurements of fluid quantities, such as density, velocity, temperature, etc., at those points change over time. To illustrate, imagine a weather report: in the Lagrangian viewpoint, you’re in a balloon floating along with the wind, measuring the pressure, temperature, and humidity of the air around you; in the Eulerian viewpoint, you’re on the ground, measuring the properties of the air as it flows past.</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>Let’s look at how these two viewpoints relate mathematically. Start with a Lagrangian description: there are particles with positions $\mathbf{x}$ and velocities $\mathbf{u}$. Consider a generic quantity $q$; each particle has a value for $q$. The function $q(t, \mathbf{x})$ tells us the value of $q$ at time $t$ for the particle at position $\mathbf{x}$—an Eulerian variable, since it’s a function of space, not of particles. How fast is $q$ changing for the particle whose position is $\mathbf{x}(t)$ as a function of time? By the chain rule: </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>\frac{\mathrm{d}}{\mathrm{d}t} q(t,\mathbf{x}(t)) &amp; = \frac{ \partial q }{ \partial t } + \nabla q \cdot \frac{\mathrm{d} \mathbf{x}}{\mathrm{d}t}  <span class="sc">\\</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>&amp;= \frac{ \partial q }{ \partial t } + \nabla q \cdot \mathbf{u} := \frac{ \mathrm{D} q }{ \mathrm{D} t }.</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>This is called the **material derivative**. So now we can answer the question above: we describe the fluid’s quantities in the Eulerian viewpoint, but when deriving the conservation of momentum, we need to treat the blob as a particle, i.e., in the Lagrangian viewpoint.</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>Continuing, using the divergence theorem, we obtain </span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>\iiint_{\Omega(t)} \rho \frac{ \mathrm{D} \mathbf{u} }{ \mathrm{D} t } \, \mathrm{d}V = \iiint_{\Omega(t)} \rho \mathbf{f} \, \mathrm{d}V + \iiint_{\Omega(t)} \nabla \cdot \boldsymbol{\sigma} \, \mathrm{d}V</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>Since this is true for any region $\Omega(t)$, the integrands must match: </span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>\frac{ \mathrm{D} \mathbf{u} }{ \mathrm{D} t } = \frac{ \partial \mathbf{u} }{ \partial t } + (\mathbf{u} \cdot \nabla)\mathbf{u} = \mathbf{f} + \frac{1}{\rho} \nabla \cdot \boldsymbol{\sigma}.</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>This is called the **Cauchy momentum equation**&nbsp;(convective form).</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="fu">### Incompressible Navier-Stokes Equations</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>We have obtained the general form for fluid motion. Now let’s make some approximations to arrive at the famous **incompressible Navier-Stokes equations**, which are widely used in computer graphics to simulate fluids. First, we take gravity as the body force and choose the stress to be $\boldsymbol{\sigma} = -p\mathbf{I} + \mu(\nabla \mathbf{u} + (\nabla \mathbf{u})^\top)$. Thus, </span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>\nabla \cdot \boldsymbol{\sigma} = -\nabla p + \nu \nabla \cdot \nabla \mathbf{u},</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>where $\nu$ is the kinematic viscosity, measuring how viscous the fluid is. Moreover, we require the fluid to be incompressible: for any fluid blob, its density must remain the same, i.e., $\mathrm{D}\rho/\mathrm{D}t = 0$. We have </span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>\frac{ \partial \rho }{ \partial t } + \nabla \cdot (\rho \mathbf{u}) &amp;= \frac{ \partial \rho }{ \partial t } + \mathbf{u} \cdot \nabla \rho + \rho \nabla \cdot \mathbf{u} <span class="sc">\\</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a> &amp;= \rho \nabla \cdot \mathbf{u} = 0 <span class="sc">\\</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>&amp;\implies \nabla \cdot \mathbf{u} = 0.</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>Putting these together, we have </span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>\frac {\mathrm{D}\mathbf {u} }{\mathrm{D}t}={\frac {\partial \mathbf {u} }{\partial t}}+(\mathbf {u} \cdot \nabla )\mathbf {u} &amp;=\nu \,\nabla \cdot \nabla\mathbf {u} -{\frac {1}{\rho }}\nabla p+ \mathbf {g} <span class="sc">\\</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>\nabla \cdot \mathbf{u} &amp;= 0.</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>The first equation is the **momentum equation**, derived from conservation of momentum; it tells us how the fluid accelerates due to the forces acting on it. The second equation is the **incompressibility condition**.</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>Let’s discuss the viscosity term, $\nu \nabla \cdot \nabla \mathbf{u}$. It is often written as the Laplacian: $\nu\Delta \mathbf{u}$. The Laplacian operator “smooths” the field, making each quantity close to its neighbors’ mean value. Thus, the viscosity term means the fluid tends to minimize differences in velocity between nearby regions, manifesting as resistance to deformation.</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>However, in most cases relevant to animation, viscosity plays a minor role and is often neglected. In fact, most numerical methods for simulating fluids introduce errors that can be physically interpreted as viscosity—so even if we drop viscosity in the equations, we still obtain results that look physically plausible. The Navier-Stokes equations without viscosity are called the **Euler equations**, and an ideal fluid with no viscosity is called **inviscid**. Explicitly,</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>\begin{align}</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>{\frac {\partial \mathbf {u} }{\partial t}}+(\mathbf {u} \cdot \nabla )\mathbf {u} &amp;=-{\frac {1}{\rho }}\nabla p+ \mathbf {g} <span class="sc">\\</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>\nabla \cdot \mathbf{u} &amp;= 0.</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>\end{align}</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>It is these equations that we’ll mostly be using.</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a><span class="fu">## Numerical Simulation</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a><span class="fu">### Discretization of Time: The Splitting Method</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>Once we have the equations, we can simulate the fluid by numerically integrating them over time. However, directly solving the equations is difficult because they are nonlinear and coupled. A common approach is to use a **splitting method**, which breaks down the complex problem into simpler subproblems that can be solved sequentially.</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>To elaborate, let's take a simple PDE as an example: $$\frac{ \partial q }{ \partial t } = f(t) + g(t),$$ In each timestep, we will split it into two simpler equations and solve these two equations one after another to approximate the solution of the original equation: $$\begin{aligned} \tilde{q} &amp;= q^n + f(q^n) \Delta t,  <span class="sc">\\</span> q^{n+1} &amp;= \tilde{q} + g(\tilde{q}) \Delta t. \end{aligned}$$ After the first step, we get an intermediate quantity $\tilde{q}$ that includes the contribution of the first term but not the second, and then the second step goes from the intermediate value to the end by adding in the missing term’s contribution. A Taylor series analysis shows that this is still a first-order-accurate algorithm:</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>q^{n+1} &amp;= (q^n + f(q^n)\Delta t) + \Delta g(q^n + f(q^n)\Delta t) <span class="sc">\\</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>&amp;= q^n + \Delta t f(q^n) + \Delta t(g(q^n) + O(\Delta t)) <span class="sc">\\</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>&amp;= q^n + \Delta t (f(q^n) + g(q^n)) + O(\Delta t^2) <span class="sc">\\</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>&amp;= q^n + \frac{\mathrm{d} q}{\mathrm{d}t} \Delta t + O(\Delta t^2).</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>Therefore, we break down the N-S equations into three simpler parts, each corresponding to a physical phenomenon: advection, body forces, and pressure projection:</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>\frac{\mathrm{D}q}{\mathrm{D}t} &amp;= 0 \iff \frac{ \partial q }{ \partial t } = -(\nabla \cdot \mathbf{u}) q, <span class="sc">\\</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>\frac{ \partial \mathbf{u} }{ \partial t } &amp;= \mathbf{g}, <span class="sc">\\</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>\frac{ \partial \mathbf{u} }{ \partial t } &amp;= -\frac{1}{\rho} \nabla p <span class="sc">\\</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>\text{s.t. } \nabla \cdot \mathbf{u} &amp;= 0.</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>We used the generic quantity $q$ in the advection equation because we may not just advect velocity. In each timestep, we solve these three parts sequentially to update the velocity field.</span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>The important guarantee is that advection should only be done in a divergence-free velocity field. When we move fluid around and want it to conserve volume, the velocity field we are moving it in must be divergence-free. So we want to make sure we only advect after enforcing the compressibility.</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a><span class="fu">### Discretization of Space: The MAC Grid</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>To represent the fluid fields in a computer, we discretize space into a grid. Each cell in the grid holds values for the fluid properties at that location. One common way to arrange these values is collocated grid, where all quantities (such as velocity components and scalar fields like pressure or density) are stored at the center of each grid cell. This layout is simple and intuitive, but it can suffer from numerical instabilities. For example, it may not resolve certain high-frequency oscillations (such as $(-1)^{i+j+k}$ patterns), leading to spurious pressure and velocity artifacts.</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>Therefore, we use a staggered, marker-and-cell grid (MAC grid), where different quantities are stored at different positions within each cell. Typically, scalar quantities (like pressure or density) are stored at the cell centers, while the components of the velocity vector are stored at the centers of the cell faces perpendicular to their respective directions (e.g., $u$ at the center of the left/right faces, $v$ at the center of the top/bottom faces, $w$ at the center of the front/back faces in 3D). This spatial staggering helps to suppress numerical artifacts. A simple 2D illustration (for a cell at $(i, j)$):</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="al">![2D MAC grid at $(i, j)$](../assets/mac_grid.png)</span>{width=500}</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>When we want to compute the value of a quantity at a position where it is not stored, we can use interpolation. For example, to get the $u$ value at the cell center $(i, j)$, we can average the $u$ values at the left and right faces:</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>u_{i,j} = \frac{u_{i-\frac{1}{2},j} + u_{i+\frac{1}{2},j}}{2}.</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>To obtain a more accurate and less diffusive result, cubic interpolation is preferred. If the cubic polynomial passes through four points $f_{-1}, f_0, f_1, f_2$ at $x = -1, 0, 1, 2$, then the value at any $x \in <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$ can be computed as</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>f(x) = \left(-\tfrac{1}{2}x + x^2 - \tfrac{1}{2}x^3\right) f_{-1}</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="ss">  + </span>\left(1 - \tfrac{5}{2}x^2 + \tfrac{3}{2}x^3\right) f_0</span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="ss">  + </span>\left(\tfrac{1}{2}x + 2x^2 - \tfrac{3}{2}x^3\right) f_1</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a><span class="ss">  + </span>\left(-\tfrac{1}{2}x^2 + \tfrac{1}{2}x^3\right) f_2.</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a><span class="fu">### Advection</span></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>To solve advection, we can use finite difference schemes to approximate the spatial derivatives. However, these methods can introduce numerical instability, as forward Euler time integration is not stable. We will instead use a simple and more phisically-intuitive method. In Lagrangian viewpoint, each fluid particle moves with the flow. Thus, we can trace the path of a fluid particle backward in time to find where it came from, and then interpolate the quantity at that position to update the current position. This is called the **semi-Lagrangian method**.</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>To be more specific, consider a grid cell centered at $\mathbf{x}_c$. We want to update the quantity $q$ at $\mathbf{x}_c$. We trace the path of a imaginary fluid particle currently at $\mathbf{x}_c$ backward in time for one timestep $\Delta t$ using the velocity field $\mathbf{u}$: $$\mathbf{x}_p = \mathbf{x}_c - \mathbf{u}(\mathbf{x}_c) \Delta t.$$ Then we interpolate the value of $q$ at $\mathbf{x}_p$ using the values at nearby grid points. This gives us the updated value of $q$ at $\mathbf{x}_c$: $$q(\mathbf{x}_c) \leftarrow q(\mathbf{x}_p).$$</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>A more sophisticated technique such as a thrid-order Runge-Kutta (RK3) method can be used to trace the path more accurately, especially when the velocity field varies significantly within a timestep: </span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>\mathbf{k}_1 &amp;= -\mathbf{u}(\mathbf{x}_c), <span class="sc">\\</span></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>\mathbf{k}_2 &amp;= -\mathbf{u}(\mathbf{x}_c + \frac{1}{2} \Delta t \mathbf{k}_1), <span class="sc">\\</span></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>\mathbf{k}_3 &amp;= -\mathbf{u}(\mathbf{x}_c + \frac{3}{4} \Delta t \mathbf{k}_2), <span class="sc">\\</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>\mathbf{x}_p &amp;= \mathbf{x}_c + \frac{\Delta t}{9} (2\mathbf{k}_1 + 3\mathbf{k}_2 + 4\mathbf{k}_3).</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a><span class="fu">### Body Force</span></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>For body force, we simply add the effect of gravity to the velocity field.</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a><span class="fu">### CFL Condition</span></span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>There is some confusion in the literature about exactly what this condition is. To keep as simple as possible, I will skip the details and just focus on what we need to implement. A more detailed explanation can be found in @bridson2015fluid.</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>The timestep $\Delta t$ must satisfy the CFL condition to ensure numerical stability. The CFL condition states that the fluid should not move more than $C$ grid cells in a single timestep. Mathematically, this can be expressed as </span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a>\Delta t \leq \frac{C\Delta x}{|u|},</span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>where $\Delta x$ are the grid cell size, and $u$ are the velocity. $C$ is a small constant integer typically set to $5$.</span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a><span class="fu">### Enforcing Incompressibility</span></span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a>To enforce incompressibility, We begin with the velocity update formula</span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a>u^{n+1} = u^{n} - \Delta t \frac{\nabla p}{\rho}.</span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>For incompressible flow, we have the continuity constraint:</span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a>\nabla \cdot u^{n+1} = 0.</span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a>Substituting the velocity update into the continuity equation:</span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>\nabla \cdot \left(u^{n} - \Delta t \frac{\nabla p}{\rho}\right) = 0.</span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>This gives us the pressure Poisson equation:</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>\nabla \cdot \left(\frac{\nabla p}{\rho}\right) = \frac{1}{\Delta t} \nabla \cdot u^{n}.</span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>For constant density $\rho$, this simplifies to:</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>\Delta p = \frac{\rho}{\Delta t} \nabla \cdot u^{n}.</span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a>We can explain this process in a more mathematically rigorous way: the incompressibility condition, $\nabla \cdot \mathbf{u} = 0$, serves as a constraint in the fluid system. When we enforce this constraint during simulation, the pressure field $p$ naturally emerges as a Lagrange multiplier.</span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a>In the context of constrained optimization, a Lagrange multiplier is introduced to enforce a constraint while minimizing (or extremizing) some quantity—in this case, the kinetic energy of the fluid. For incompressible flow, we seek a velocity field that is as close as possible to the unconstrained (intermediate) velocity, but which also satisfies the divergence-free condition. The pressure term in the Navier-Stokes equations acts as the Lagrange multiplier that enforces this constraint at every point in the domain.</span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>Mathematically, this means that the pressure is not an independent physical variable, but rather a quantity that arises to ensure the velocity field remains divergence-free. When we solve the pressure Poisson equation during the projection step, we are effectively finding the Lagrange multiplier that enforces incompressibility.</span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a>Combining the discrete operators, we get the discrete pressure Poisson equation:</span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a>\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{(\Delta x)^2} + \frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{(\Delta y)^2} = \frac{\rho}{\Delta t} \left( \frac{u^n_{i+\frac{1}{2},j} - u^n_{i-\frac{1}{2},j}}{\Delta x} + \frac{v^n_{i,j+\frac{1}{2}} - v^n_{i,j-\frac{1}{2}}}{\Delta y} \right).</span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a>Let $N_x$ and $N_y$ be the number of cells in x and y directions. We have $N_x \times N_y$ unknown pressures. The discrete equation can be written as:</span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a>A\mathbf{p} = \mathbf{b}.</span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a>where $\mathbf{p}$ is the pressure vector of size $N_x N_y \times 1$; $A$ is the coefficient matrix of size $N_x N_y \times N_x N_y$; $\mathbf{b}$ is the right-hand side vector of size $N_x N_y \times 1$.</span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a>This sparse linear system can be solved using iterative methods such as the Conjugate Gradient (CG) method or Multigrid methods. A preconditioner, such as the MIC(0) (Modified Incomplete Cholesky with zero-fill), can be used to accelerate convergence. After obtaining the pressure field, we can update the velocity field to ensure it is divergence-free.</span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a><span class="fu">## Code Sample: 2D Smoke Simulation</span></span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a>The code sample demonstrates a simple 2D smoke simulation implemented in Python using the warp library. You could find it on <span class="co">[</span><span class="ot">GitHub</span><span class="co">](https://github.com/TempContainer/simple-fluid)</span>. The simulation solves the incompressible Euler equations on a MAC grid, using semi-Lagrangian advection, pressure projection, and buoyancy forces as body force to model the motion of smoke. The results are visualized in real time using Matplotlib.</span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a><span class="al">![2D smoke simulation](../assets/smoke2d.mp4)</span></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a>A major advantage of using cubic interpolation is evident when comparing my implementation to warp’s official fluid simulation demo, which use linear interpolation. <span class="co">[</span><span class="ot">Also they do not use MAC grid, RK3 integration scheme, and a conjugate gradient solver to solve the Poisson equation. </span><span class="co">]</span>{.aside} The cubic approach produces noticeably finer and more detailed turbulence patterns in the simulated smoke.</span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a><span class="al">![warp's official fluid simulation. Poor turbulence detail is showed as the absence of high-order interpolation.](../assets/warp_fluid.png)</span></span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a><span class="fu">## References</span></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a>Most of the content in this post is adapted from @bridson2015fluid, which is an excellent book on fluid simulation for beginners. Also, @kim2017fluid is a great resource with code samples for fluid simulation.</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://creativecommons.org/wp-content/themes/vocabulary-theme/vocabulary/svg/cc/icons/cc-icons.svg#cc-logo" class="img-fluid" alt="CC" width="25"><img src="https://creativecommons.org/wp-content/themes/vocabulary-theme/vocabulary/svg/cc/icons/cc-icons.svg#cc-by" class="img-fluid" alt="CC" width="25"><img src="https://creativecommons.org/wp-content/themes/vocabulary-theme/vocabulary/svg/cc/icons/cc-icons.svg#cc-sa" class="img-fluid" alt="CC" width="25"></a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>